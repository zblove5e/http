# 为什么要弄懂HTTP缓存机制?
## 前言 浏览器为什么缓存静态资源?怎么缓存?缓存怎样生效?
### 介绍HTTP报文
```
http报文就是浏览器和服务器之间通信时,发送和响应的数据块
	浏览器---(请求报文)--->服务器
	服务器<---(响应报文)---服务器
```
1. 包含属性的头部
	```text
		附件信息(cookie,缓存信息)与缓存相关的规则信息
	```
2. 包含数据的主体
	```text
		HTTP请求真正的部分
	```
	
## 缓存规则解析
我们可以假设浏览器内部有一个作缓存的数据库,存放缓存信息
过程:
![首次缓存机制](./img/01.png)
- 缓存分类:
	```text
	强制缓存: 当浏览器请求数据的时,先到缓存数据库中查找缓存数据是否存在及过期，如果数据过期,则浏览器会得到缓存数据失效的响应, 此时浏览器继续发出请求-目的地是服务器,服务器将数据和数据缓存规则 返回给浏览器,浏览器将数据按照缓存规则存入缓存数据库--------缓存数据库决定数据是否过期（不一定真的过期）优点是快，请求少
	对比缓存: 当浏览器需要数据的时候会请求缓存数据库这批数据的标识,缓存数据库会将数据存储标识返回给浏览器,浏览器将本次需要的存储数据标识发送给服务器,服务器返回给浏览器本次数据标识是否过期,浏览器得到的响应如果是缓存数据没有过期 便会去缓存数据库中获取数据。------------服务器决定数据是否过期（决定性的）优点是拿的数据永远是最新的数据
	总结“ 强制缓存在有效期内 浏览器是不会与服务器交互；而对比缓存是一定要与服务器交互的。 两种缓存可以同时存在，强制缓存优先于对比缓存，当执行强制缓存规则，如果缓存生效，就不再执行对比缓存了
	```
- 问题来了：强制缓存优先级高，怎么保证强制缓存的数据是有效期内的？
	+ 缓存规则信息在响应头中会体现: **Expires/Cache-Control** ,如下图
		![谷歌交互缓存图](./img/02.png)
	```
	Expires 的值是服务器返回的缓存数据到期时间,下次请求时间如果小于服务端的到期时间,就直接使用缓存数据. Expires是Http1.0的现在浏览器默认是使用Http1.1的,所以它的作用不大
	```
- 另外一个问题,到期时间由服务端生成,但客户端的时间有和服务器不同的时候,这回导致缓存命中(就是确定缓存过不过期)有误差,所以在Http1.1使用Cache-Control代替Expires---**什么是Cache-Control?**
	```
	cache-control是最重要的规则,常见取值有private/public/no-cache/max-age/no-store/  默认是private
	private :  客户端可以缓存
	public : 客户端和代理服务器都可以缓存(代理服务器和服务器类似,在网络上减少服务器负载的一台服务器,存放了缓存数据)
	max-age=XXX : 缓存内容在XXX后过期
	no-cache : 需要对比缓存验证
	no-store : 所有内容都不缓存,不强制缓存,不对比缓存(前端不喜欢这个,影响用户体验)
	```
- 举例:
- 
 ![缓存控制](./img/03.png)
```
上图中cache-control只制定了max-age,默认是private,缓存事件为31...秒(1年),也就是一年内再次请求这条数据,都会直接从缓存数据库中获取)
```

## 对比缓存**304状态码**
```
先和服务器交互发送缓存数据状态判断能否可用,再使用缓存----可爱的304 
```
**第一次访问 200**
![首次请求200状态码](./img/04.png)
**第二次访问 304**
![后续请求304状态码](./img/05.png)
```
注意两次的**status** 和 **time**

```